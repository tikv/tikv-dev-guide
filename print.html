<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>TiKV Development Guide</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> TiKV Development Guide</a></li><li class="chapter-item expanded "><a href="get-started/intro.html"><strong aria-hidden="true">2.</strong> Get Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="get-started/build-tikv-from-source.html"><strong aria-hidden="true">2.1.</strong> Build TiKV from Source</a></li><li class="chapter-item expanded "><a href="get-started/import-tikv-into-an-ide.html"><strong aria-hidden="true">2.2.</strong> Import TiKV into an IDE</a></li><li class="chapter-item expanded "><a href="get-started/write-and-run-unit-tests.html"><strong aria-hidden="true">2.3.</strong> Write and Run Unit Tests</a></li><li class="chapter-item expanded "><a href="get-started/debug-and-profile.html"><strong aria-hidden="true">2.4.</strong> Debug and Profile</a></li><li class="chapter-item expanded "><a href="get-started/submit-a-pull-request.html"><strong aria-hidden="true">2.5.</strong> Submit a Pull Request</a></li></ol></li><li class="chapter-item expanded "><a href="contribute-to-tikv/intro.html"><strong aria-hidden="true">3.</strong> Contribute to TiKV</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contribute-to-tikv/community-guideline.html"><strong aria-hidden="true">3.1.</strong> Community Guideline</a></li><li class="chapter-item expanded "><a href="contribute-to-tikv/committer-guide.html"><strong aria-hidden="true">3.2.</strong> Committer Guide</a></li><li class="chapter-item expanded "><a href="contribute-to-tikv/report-a-bug.html"><strong aria-hidden="true">3.3.</strong> Report a Bug</a></li><li class="chapter-item expanded "><a href="contribute-to-tikv/contribute-code.html"><strong aria-hidden="true">3.4.</strong> Contribute code</a></li><li class="chapter-item expanded "><a href="contribute-to-tikv/review-a-pull-request.html"><strong aria-hidden="true">3.5.</strong> Review a Pull Request</a></li><li class="chapter-item expanded "><a href="contribute-to-tikv/request-for-comments.html"><strong aria-hidden="true">3.6.</strong> Request for Comments</a></li><li class="chapter-item expanded "><a href="contribute-to-tikv/code-style-and-quality-guide.html"><strong aria-hidden="true">3.7.</strong> Code Style and Quality Guide</a></li><li class="chapter-item expanded "><a href="contribute-to-tikv/write-document.html"><strong aria-hidden="true">3.8.</strong> Write document</a></li></ol></li><li class="chapter-item expanded "><a href="understanding-tikv/intro.html"><strong aria-hidden="true">4.</strong> Understanding TiKV</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="understanding-tikv/overview/intro.html"><strong aria-hidden="true">4.1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="understanding-tikv/overview/raw-kv.html"><strong aria-hidden="true">4.1.1.</strong> Raw KV</a></li><li class="chapter-item expanded "><a href="understanding-tikv/overview/transaction-kv.html"><strong aria-hidden="true">4.1.2.</strong> Transaction KV</a></li></ol></li><li class="chapter-item expanded "><a href="understanding-tikv/scalability/intro.html"><strong aria-hidden="true">4.2.</strong> Scalability</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="understanding-tikv/scalability/region.html"><strong aria-hidden="true">4.2.1.</strong> Region</a></li><li class="chapter-item expanded "><a href="understanding-tikv/scalability/scheduling.html"><strong aria-hidden="true">4.2.2.</strong> Scheduling</a></li></ol></li><li class="chapter-item expanded "><a href="understanding-tikv/high-availability/intro.html"><strong aria-hidden="true">4.3.</strong> High Availability</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="understanding-tikv/high-availability/raft/intro.html"><strong aria-hidden="true">4.3.1.</strong> Raft</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="understanding-tikv/high-availability/raft/raft-rs.html"><strong aria-hidden="true">4.3.1.1.</strong> raft-rs</a></li><li class="chapter-item expanded "><a href="understanding-tikv/high-availability/raft/leader-lease.html"><strong aria-hidden="true">4.3.1.2.</strong> Leader Lease</a></li><li class="chapter-item expanded "><a href="understanding-tikv/high-availability/raft/hibernate-region.html"><strong aria-hidden="true">4.3.1.3.</strong> Hibernate Region</a></li></ol></li><li class="chapter-item expanded "><a href="understanding-tikv/high-availability/multi-raft/intro.html"><strong aria-hidden="true">4.3.2.</strong> Multi-Raft</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="understanding-tikv/high-availability/multi-raft/split.html"><strong aria-hidden="true">4.3.2.1.</strong> Split</a></li><li class="chapter-item expanded "><a href="understanding-tikv/high-availability/multi-raft/merge.html"><strong aria-hidden="true">4.3.2.2.</strong> Merge</a></li></ol></li><li class="chapter-item expanded "><a href="understanding-tikv/high-availability/raftstore/intro.html"><strong aria-hidden="true">4.3.3.</strong> RaftStore</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="understanding-tikv/high-availability/raftstore/actor-model.html"><strong aria-hidden="true">4.3.3.1.</strong> Actor Model</a></li><li class="chapter-item expanded "><a href="understanding-tikv/high-availability/raftstore/fsm.html"><strong aria-hidden="true">4.3.3.2.</strong> FSM</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="understanding-tikv/transaction/intro.html"><strong aria-hidden="true">4.4.</strong> Transaction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="understanding-tikv/transaction/percolator/intro.html"><strong aria-hidden="true">4.4.1.</strong> Percolator</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="understanding-tikv/transaction/percolator/tso.html"><strong aria-hidden="true">4.4.1.1.</strong> TSO</a></li><li class="chapter-item expanded "><a href="understanding-tikv/transaction/percolator/encode.html"><strong aria-hidden="true">4.4.1.2.</strong> Encode</a></li><li class="chapter-item expanded "><a href="understanding-tikv/transaction/percolator/command.html"><strong aria-hidden="true">4.4.1.3.</strong> Command</a></li><li class="chapter-item expanded "><a href="understanding-tikv/transaction/percolator/latch-and-scheduler.html"><strong aria-hidden="true">4.4.1.4.</strong> Latch and Scheduler</a></li></ol></li><li class="chapter-item expanded "><a href="understanding-tikv/transaction/pessimistic-transaction.html"><strong aria-hidden="true">4.4.2.</strong> Pessimistic Transaction</a></li><li class="chapter-item expanded "><a href="understanding-tikv/transaction/async-commit.html"><strong aria-hidden="true">4.4.3.</strong> Async Commit</a></li><li class="chapter-item expanded "><a href="understanding-tikv/transaction/1pc.html"><strong aria-hidden="true">4.4.4.</strong> 1PC</a></li><li class="chapter-item expanded "><a href="understanding-tikv/transaction/stale-read.html"><strong aria-hidden="true">4.4.5.</strong> Stale Read</a></li><li class="chapter-item expanded "><a href="understanding-tikv/transaction/cdc.html"><strong aria-hidden="true">4.4.6.</strong> CDC</a></li></ol></li><li class="chapter-item expanded "><a href="understanding-tikv/storage/intro.html"><strong aria-hidden="true">4.5.</strong> Storage</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="understanding-tikv/storage/rocksdb.html"><strong aria-hidden="true">4.5.1.</strong> RocksDB</a></li><li class="chapter-item expanded "><a href="understanding-tikv/storage/encode.html"><strong aria-hidden="true">4.5.2.</strong> Encode</a></li><li class="chapter-item expanded "><a href="understanding-tikv/storage/import-and-export.html"><strong aria-hidden="true">4.5.3.</strong> Import and Export</a></li><li class="chapter-item expanded "><a href="understanding-tikv/storage/io-rate-limiter.html"><strong aria-hidden="true">4.5.4.</strong> IO Rate Limiter</a></li></ol></li><li class="chapter-item expanded "><a href="understanding-tikv/coprocessor/intro.html"><strong aria-hidden="true">4.6.</strong> Coprocessor</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="understanding-tikv/coprocessor/tidb-expression-executor.html"><strong aria-hidden="true">4.6.1.</strong> TiDB Expression Executor</a></li><li class="chapter-item expanded "><a href="understanding-tikv/coprocessor/coprocessor-plugin.html"><strong aria-hidden="true">4.6.2.</strong> Coprocessor Plugin</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">TiKV Development Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/tisonkun/tikv-dev-guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tikv-development-guide"><a class="header" href="#tikv-development-guide">TiKV Development Guide</a></h1>
<p>This guide is meant to help document how TiKV works, as well as to help new contributors get involved in TiKV development.</p>
<p>There are three parts to this guide:</p>
<ol>
<li><a href="get-started/intro.html">Get Started</a></li>
<li><a href="contribute-to-tikv/intro.html">Contribute to TiKV</a></li>
<li><a href="understanding-tikv/intro.html">Understanding TiKV</a></li>
</ol>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="get-started"><a class="header" href="#get-started">Get Started</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="build-tikv-from-source"><a class="header" href="#build-tikv-from-source">Build TiKV from Source</a></h1>
<p>TiKV is mostly written in Rust, and has components written in C++ (RocksDB, gRPC). We are currently using the Rust <a href="https://rust-lang.github.io/rustup/concepts/toolchains.html">nightly toolchain</a>. To provide consistency, we use linters and automated formatting tools.</p>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<p>To build TiKV you'll need to at least have the following installed:</p>
<ul>
<li><a href="https://git-scm.com/"><code>git</code></a> - Version control</li>
<li>[<code>rustup</code>] - Rust installer and toolchain manager</li>
<li><a href="https://www.gnu.org/software/make/"><code>make</code></a> - Build tool (run common workflows)</li>
<li><a href="https://cmake.org/"><code>cmake</code></a> - Build tool (required for [gRPC])</li>
<li><a href="https://www.gnu.org/software/gawk/manual/gawk.html"><code>awk</code></a> - Pattern scanning/processing language</li>
<li>C++ compiler - <a href="https://gcc.gnu.org/"><code>gcc</code></a> 4.9+ (required for [gRPC])</li>
</ul>
<p>If you are targeting platforms other than x86_64 linux, you'll also need:</p>
<ul>
<li><a href="http://releases.llvm.org/download.html"><code>llvm</code> and <code>clang</code></a> - Used to generate bindings for different platforms and build native libraries (required for grpcio, rocksdb).</li>
</ul>
<p><em>(Latest version of the above tools should work in most cases. When encountering any trouble of building TiKV, try upgrading to the latest. If it is not helped, do not hesitate to <a href="get-started/build-tikv-from-source.html#ask-for-help">ask</a>.)</em></p>
<h3 id="getting-the-repository"><a class="header" href="#getting-the-repository">Getting the repository</a></h3>
<pre><code>git clone https://github.com/tikv/tikv.git
cd tikv
# Future instructions assume you are in this directory
</code></pre>
<h3 id="building-and-testing"><a class="header" href="#building-and-testing">Building and testing</a></h3>
<p>TiKV includes a <a href="https://github.com/tikv/tikv/blob/master/Makefile"><code>Makefile</code></a> that has common workflows and sets up a standard build environment. You can also use [<code>cargo</code>], as you do in many other Rust projects. To run <code>cargo</code> commands in the same environment as the <code>Makefile</code> to avoid re-compilations due to environment changes, you can prefix the command with <a href="https://github.com/tikv/tikv/blob/master/scripts/env"><code>scripts/env</code></a>, for example: <code>./scripts/env cargo build</code>.</p>
<p>Furthermore, when building by <code>make</code>, <code>cargo</code> is configured to use <a href="https://internals.rust-lang.org/t/evaluating-pipelined-rustc-compilation/10199">pipelined compilation</a> to increase the parallelism of the build. To turn on pipelining while using <code>cargo</code> directly, set environment variable <code>export CARGO_BUILD_PIPELINING=true</code>.</p>
<p>To build TiKV:</p>
<pre><code class="language-bash">make build
</code></pre>
<p>During interactive development, you may prefer using <code>cargo check</code>, which will parse, do borrow check, and lint your code, but not actually compile it:</p>
<pre><code class="language-bash">./scripts/env cargo check --all
</code></pre>
<p>It is particularly handy alongside <code>cargo-watch</code>, which runs a command each time you change a file.</p>
<pre><code class="language-bash">cargo install cargo-watch
cargo watch -s &quot;./scripts/env cargo check --all&quot;
</code></pre>
<p>When you're ready to test out your changes, use the <code>dev</code> task. It will format your codebase, build with <code>clippy</code> enabled, and run tests. In most case, this should be done without any failure before you create a Pull Request. Unfortunately, some tests will fail intermittently or can not pass on your platform. If you're unsure, just <a href="get-started/build-tikv-from-source.html#ask-for-help">ask</a>!</p>
<pre><code class="language-bash">make dev
</code></pre>
<p>You can run the test suite alone, or just run a specific test:</p>
<pre><code class="language-bash"># Run the full suite
make test
# Run a specific test
./scripts/test $TESTNAME -- --nocapture
</code></pre>
<p>TiKV follows the Rust community coding style. We use <a href="https://github.com/rust-lang/rustfmt">rustfmt</a> and <a href="https://github.com/rust-lang/rust-clippy">clippy</a> to automatically format and lint our codes. Using these tools is included in our CI. They are also part of <code>make dev</code>, and you can run them alone:</p>
<pre><code class="language-bash"># Run Rustfmt
make format
# Run Clippy (note that some lints are ignored, so `cargo clippy` will give many false positives)
make clippy
</code></pre>
<p>See the <a href="https://github.com/rust-lang/rfcs/blob/master/style-guide/README.md">Rust Style Guide</a> and the <a href="https://rust-lang-nursery.github.io/api-guidelines/">Rust API Guidelines</a> for details on the conventions.</p>
<p>Please follow this style to make TiKV easy to review, maintain, and develop.</p>
<h3 id="build-for-debugging"><a class="header" href="#build-for-debugging">Build for Debugging</a></h3>
<p>To reduce compilation time, TiKV builds do not include full debugging information by default — <code>release</code> and <code>bench</code> builds include no debuginfo; <code>dev</code> and <code>test</code> builds include line numbers only. The easiest way to enable debuginfo is to precede build commands with <code>RUSTFLAGS=-Cdebuginfo=1</code> (for line numbers), or <code>RUSTFLAGS=-Cdebuginfo=2</code> (for full debuginfo). For example,</p>
<pre><code class="language-bash">RUSTFLAGS=-Cdebuginfo=2 make dev
RUSTFLAGS=-Cdebuginfo=2 ./scripts/env cargo build
</code></pre>
<h3 id="ask-for-help"><a class="header" href="#ask-for-help">Ask for help</a></h3>
<p>If you encounter any problem during your journey, do not hesitate to reach out on the <a href="https://internals.tidb.io/">TiDB Internals forum</a>.
[<code>rustup</code>]: https://rustup.rs/
[<code>cargo</code>]: https://doc.rust-lang.org/cargo/
[gRPC]: https://github.com/grpc/grpc
[rustfmt]: https://github.com/rust-lang/rustfmt
[clippy]: https://github.com/rust-lang/rust-clippy</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="import-tikv-into-an-ide"><a class="header" href="#import-tikv-into-an-ide">Import TiKV into an IDE</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="write-and-run-unit-tests"><a class="header" href="#write-and-run-unit-tests">Write and Run Unit Tests</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="debug-and-profile"><a class="header" href="#debug-and-profile">Debug and Profile</a></h1>
<p>In previous chapter, we introduce how to build TiKV from source, and in this chapter, we will focus on how to debug and profile TiKV from the view of a developer.</p>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<ul>
<li>rust-gdb or rust-lldb<br />
<a href="https://www.sourceware.org/gdb">GDB</a> and <a href="https://lldb.llvm.org/">LLDB</a> are commonly used for debugging a program.
<ul>
<li><code>rust-gdb</code> and <code>rust-lldb</code> are both installed with <code>rustup</code> together, however, they depend on <code>GDB</code> and <code>LLDB</code>, which are need to be installed by yourself. Here is the installation of GDB/LLDB.</li>
</ul>
<pre><code class="language-bash">Ubuntu: sudo apt-get install gdb/lldb
CentOS: sudo yum install gdb/lldb
</code></pre>
<ul>
<li><code>GDB</code> and <code>LLDB</code> can also be used to debug rust program.</li>
<li>Basically, <code>rust-gdb</code> is a wrapper that loads external Python pretty-printing scripts into GDB. This is useful (and somewhat necessary) when debugging more complex Rust programs because it significantly improves the display of Rust data types. <code>rust-lldb</code> is similar. So <code>rust-gdb</code> and <code>rust-lldb</code> are recommended.</li>
<li>About how to choose between <code>rust-gdb</code> and <code>rust-lldb</code>, it depends on the platform you are using and the familiarity of these tools. If you are new hand on the debugging tools, <code>rust-lldb</code> is recommended on MacOS and <code>rust-gdb</code> is recommended on Linux, like Ubuntu and CentOS. </li>
</ul>
</li>
<li>perf<br />
<a href="https://perf.wiki.kernel.org/index.php/Main_Page">Perf</a> is common Linux profiler. It's powerful: it can instrument CPU performance counters, tracepoints, kprobes, and uprobes (dynamic tracing). It can be installed as following:</li>
</ul>
<pre><code class="language-bash">Ubuntu: sudo apt-get install linux-tools
CentOS: sudo yum install perf
</code></pre>
<p><em>For simplicity, we will introduce the debugging with rust-gdb, audience can also use rust-lldb.</em></p>
<h2 id="debug-tikv-with-rust-gdb"><a class="header" href="#debug-tikv-with-rust-gdb">Debug TiKV with rust-gdb</a></h2>
<h3 id="debug-a-unit-test-binary-in-tikv"><a class="header" href="#debug-a-unit-test-binary-in-tikv">Debug a unit test binary in TiKV</a></h3>
<ol>
<li>Build the unit test binary, for example we want to debug the test case: <a href="https://github.com/tikv/tikv/blob/a7d1595f5486616be34e0cf2bbf372edb5f0e85a/src/storage/mod.rs#L5352-L5356">test_raw_get_key_ttl</a></li>
</ol>
<p>Firstly, we can get the binary file with cargo command, like: </p>
<pre><code class="language-bash">cargo test -p tikv test_raw_get_key_ttl
</code></pre>
<p>A binary file located in <code>target/debug/deps/tikv-some-hash</code> will be produced.</p>
<ol start="2">
<li>Debug the binary with rust-gdb:</li>
</ol>
<pre><code class="language-bash">rust-gdb --args target/debug/deps/tikv-4a32c89a00a366cb test_raw_get_key_ttl
</code></pre>
<ol start="3">
<li>Now the standard gdb interface is shown. We can debug the unit test with gdb command. Here are some simple commands.</li>
</ol>
<ul>
<li>r(run) to start the program.</li>
<li>b(break) file_name:line_number to set a breakpoint.</li>
<li>p(print) args to print args.</li>
<li>ls to show the surrounding codes of breakpoint.</li>
<li>s(step) to step in the function.</li>
<li>n(next) to step over current line.</li>
<li>c(continue) to continue the program.</li>
<li>watch to set a data watch breakpoint.</li>
</ul>
<p>An example of debugging an unit test named <code>test_raw_batch_get</code> is as following:</p>
<ul>
<li>Build <code>tikv</code> unit test binary with <code>cargo test -p tikv test_raw_batch_get</code> and binary is located in <code>target/debug/deps/tikv-&lt;somehash&gt;</code></li>
<li>Launch the binary with <code>rust-gdb</code></li>
</ul>
<pre><code>rust-gdb --args target/debug/deps/tikv-&lt;somehash&gt; test_raw_batch_get
</code></pre>
<ul>
<li>debug </li>
</ul>
<p><img src="get-started/../media/gdb_tikv_ut.png" alt="gdb-tikv-ut" /></p>
<p>As the marks shown in above screenshot, firstly, a breakpoint is set in line <code>4650</code> of file <code>src/storage/mod.rs</code> and set condition that <code>api_version == 2</code>, which means program only pause when it hit here and the variable <code>api_version</code> is equals to 2. Then <code>run</code> is executed and the program start to run. The following steps are some examples to use gdb commands to execute the <code>step over</code> and <code>print</code>.</p>
<h3 id="debug-tikv-cluster-with-specified-tikv-server-binary"><a class="header" href="#debug-tikv-cluster-with-specified-tikv-server-binary">Debug TiKV cluster with specified tikv-server binary</a></h3>
<ol>
<li>Build tikv-server binary with the guide in <a href="get-started/./build-tikv-from-source.html">previous chapter</a>.</li>
<li>The binary files are located in <code>\${TIKV_SOURCE_CODE}/target/debug/tikv-server</code>. Debug binary is recommended as it keep much useful debug info, such as codes, lines, local variables.</li>
<li>TiUP is recommended to deploy a TiKV cluster. It's easy to deploy a local TiKV cluster with tiup playground. Please refer to <a href="https://tikv.org/docs/5.1/concepts/tikv-in-5-minutes/#set-up-a-local-tikv-cluster-with-the-default-options">Get start in 5 minutes</a>. With TiUP, we can also specify the tikv-server binary file during deploy. The following is an example:</li>
</ol>
<pre><code class="language-bash">TIKV_BIN=~/tikv/target/release/tikv-server

tiup playground v5.0.4 --mode tikv-slim 
  --kv 3 --kv.binpath ${TIKV_BIN} --kv.config ./tikv_rawkv.toml
</code></pre>
<ol start="4">
<li>Now we get one TiKV cluster with three TiKV virtual nodes and one PD node. we can use <code>rust-gdb</code> to attach the <code>tikv-server</code> process.</li>
</ol>
<pre><code class="language-bash">rust-gdb attach `pid of tikv-server`
</code></pre>
<p>pid of tikv-server can be obtained with the following command:</p>
<pre><code class="language-bash">ps -aux|grep tikv-server
</code></pre>
<p>Now the standard GDB interface is shown. The following steps are just the same as debugging unit test binary.</p>
<h2 id="profiling-tikv"><a class="header" href="#profiling-tikv">Profiling TiKV</a></h2>
<p>When we want to find the CPU bottleneck of one program, we can use <a href="https://www.brendangregg.com/perf.html">perf Linux profiler</a> to find the procedures and how much CPU time they are consuming. It can also be used for profiling TiKV. <a href="http://www.brendangregg.com/flamegraphs.html">FlameGraph</a> can also be used to visualize stack traces with interactive SVGs. FlameGraph can be downloaded from here: </p>
<pre><code>git clone https://github.com/brendangregg/FlameGraph.git
</code></pre>
<p>Here is one example:</p>
<ol>
<li>Recording performance data with <code>perf</code></li>
</ol>
<pre><code>perf record -g -p `pidof tikv-server`
</code></pre>
<ol start="2">
<li>Generate text report</li>
</ol>
<pre><code>perf report
</code></pre>
<ol start="3">
<li>Parse the perf data with script.</li>
</ol>
<pre><code>perf script -i perf.data &amp;&gt; perf.unfold
</code></pre>
<ol start="4">
<li>Generate the flame graph</li>
</ol>
<pre><code>./stackcollapse-perf.pl perf.unfold &amp;&gt; perf.folded

./flamegraph.pl perf.folded &gt; perf.svg
</code></pre>
<ol start="5">
<li>We can open the <code>svg</code> file with <code>Chrome</code> or other browsers. With the flame graph, we can see the performance data more intuitively.</li>
</ol>
<p><img src="get-started/../media/perf_flame.png" alt="flame_graph" /></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="submit-a-pull-request"><a class="header" href="#submit-a-pull-request">Submit a Pull Request</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="contribute-to-tikv"><a class="header" href="#contribute-to-tikv">Contribute to TiKV</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="community-guideline"><a class="header" href="#community-guideline">Community Guideline</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="committer-guide"><a class="header" href="#committer-guide">Committer Guide</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="report-a-bug"><a class="header" href="#report-a-bug">Report a Bug</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="contribute-code"><a class="header" href="#contribute-code">Contribute code</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="review-a-pull-request"><a class="header" href="#review-a-pull-request">Review a Pull Request</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="request-for-comments"><a class="header" href="#request-for-comments">Request for Comments</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="code-style-and-quality-guide"><a class="header" href="#code-style-and-quality-guide">Code Style and Quality Guide</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="write-document"><a class="header" href="#write-document">Write document</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="understanding-tikv"><a class="header" href="#understanding-tikv">Understanding TiKV</a></h1>
<p>TiKV is a distributed, transactional key-value database. It is fully ACID compliant and features automatic horizontal scalability, global data consistency, geo-replication, and many other features. It can be used as a building block for other high-level services.</p>
<p>In this chapter, we will introduce everything about the design and implementation of TiKV. We hope that through this chapter, you can develop a deep understanding of TiKV, and build your knowledge of distributed programming.</p>
<h2 id="history"><a class="header" href="#history">History</a></h2>
<p>In the middle of 2015, we decided to build a database which solved MySQL's scaling problems. At that time, the most common way to increase MySQL's scalability was to build a proxy on top of MySQL that distributes the load more efficiently, but we don't think that is the best way.</p>
<p>As far as we knew, proxy-based solutions have following problems:</p>
<ul>
<li>Building a proxy on top of the MySQL servers cannot guarantee ACID compliance. Notably, the cross-node transactions are not supported natively.</li>
<li>It poses great challenges for business flexibility because the users have to worry about the data distribution and design their sharding keys carefully to avoid inefficient queries.</li>
<li>The high availability and data consistency of MySQL cannot be guaranteed easily based on the traditional Source-Replica replication.</li>
</ul>
<p>Although building a proxy based on MySQL directly might be easy at the beginning, we still decided to chose another way, a more difficult path — to build a distributed, MySQL compatible database from scratch.</p>
<p>Fortunately, Google met the same problem and had already published some papers to describe how they built <a href="http://static.googleusercontent.com/media/research.google.com/en//archive/spanner-osdi2012.pdf">Spanner</a> and <a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/41344.pdf">F1</a> to solve it. Spanner is a globally distributed, externally consistent database and F1 is a distributed SQL database based on Spanner. Inspired by Spanner and F1, we knew we could do the same thing. So we started to build TiDB - a stateless MySQL layer like F1. After we released TiDB, we knew we needed an underlying Spanner-like database so we began to develop TiKV.</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>The diagram below shows the architecture of TiKV:</p>
<p><img src="understanding-tikv/../media/basic-architecture.png" alt="basic-architecture" /></p>
<p>In this illustration, there are four TiKV instances in the cluster and each instance uses one key-value engine to save data. On top of key-value engine, TiKV uses the <a href="https://raft.github.io/">Raft</a> consensus algorithm to replicate the data. In practice, we use at least three replicas to keep data safe and consistent, and these replicas form a Raft group.</p>
<p>We use the traditional multiversion concurrency control (MVCC) mechanism and have built a distributed transaction layer above the Raft layer. We also provide a Coprocessor framework so that users can push down their computing logic to the storage layer.</p>
<p>All the network communications are through gRPC so that contributors can develop their own clients easily.</p>
<p>The whole cluster is managed and scheduled by a central service: the Placement Driver (PD).</p>
<p>As you can see, the hierarchy of TiKV is clear and easy to understand, and we will give more detailed explanation later.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<blockquote>
<p>Talk about the architecture</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="raw-kv"><a class="header" href="#raw-kv">Raw KV</a></h1>
<blockquote>
<p>How raw get and raw put are processed</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="transaction-kv"><a class="header" href="#transaction-kv">Transaction KV</a></h1>
<blockquote>
<p>How 2PC works, how prewrite and commit are processed. (only focus on the optimistic transaction)</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="scalability"><a class="header" href="#scalability">Scalability</a></h1>
<p>In the database field, <code>Scalability</code> is the term we use to describe the capability of a system to handle a growing amount of storage or computation. Even if a system is working reliably and fast on a small scale today, it doesn't mean it will necessarily work well in the future, especially when the increased load exceeds what the system can process. In modern systems, the amount of data we have to process can far outgrow our original expectations, so scalability is a critical consideration for the design of a database.</p>
<p>There are two main types of scalability:</p>
<ol>
<li>
<p>Vertical scaling, which is also known as <strong>scaling up</strong>, means adding resources to a single node in a system, typically involving the improvement of CPU, memory, or storage, to become a more powerful single computer. Vertical scaling is limited by the technology of the semiconductor industry, and the cost per hertz of CPU or byte of memory/storage will increase dramatically when near the technical limit.</p>
</li>
<li>
<p>Horizontal scaling, which is also known as <strong>scaling out</strong>, means adding more machines to a system and distributing the load across multiple smaller machines. As computer prices have dropped and performance continues to increase, high-performance computing applications have adopted low-cost commodity systems for tasks. System architects may deploy hundreds of small computers in a cluster, to obtain aggregate computing power that is far more powerful than a system based on a stand-alone single computer. Moreover, with the widespread use of <a href="https://en.wikipedia.org/wiki/Cloud_computing">Cloud computing</a> technology, horizontal scalable is necessary for a system to adapt to the resiliency of Cloud.</p>
</li>
</ol>
<p>A system whose performance improves after adding hardware, proportionally to the added quantity, is said to be a scalable system. It's obvious that a scalable system depends on the ability of horizontal scaling.</p>
<p>TiKV is a highly scalable key-value store, especially comparing with other stand-alone key-value stores like <a href="https://rocksdb.org/">RocksDB</a> and <a href="https://github.com/google/leveldb">LevelDB</a>.</p>
<p>To be scalable, TiKV needs to solve the following problems:</p>
<ol>
<li>
<p>Partitioning: how to break data up into partitions, also known as <em>sharding</em>, to fully utilize resources of nodes in cluster. In TiKV, a partition is called a <code>Region</code>.</p>
</li>
<li>
<p>Scheduling: how to distribute the Regions in cluster, for balancing the load among all nodes, and eliminating hot spots or other bottle necks.</p>
</li>
</ol>
<p>In the rest of this chapter, we will talk about <code>Region</code> and <code>Scheduling</code> of TiKV.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="region"><a class="header" href="#region">Region</a></h1>
<p><strong>Sharding</strong> is one of the most necessary characteristic for a storage system to be scalable (or more specifically, <a href="https://en.wikipedia.org/wiki/Scalability">horizontally scalable</a>). By breaking data up into partitions, a storage system can distribute data across computers in the cluster, to fully utilize resource of every single node. Meanwhile, migrate partitions to re-balance computing and storage loads when adding nodes to cluster, to gain performance improvement proportional to the increasing of number of nodes, i.e, to archive <strong>Scalability</strong>.</p>
<p><img src="understanding-tikv/scalability/../../media/scalability-data-sharding.png" alt="scalability-data-sharding" />
<em>Diagram 1, Data Sharding [1]</em></p>
<p>In TiKV, partition is named as <code>Region</code>, which is the data unit to be distributed and migrated among TiKV nodes. Region is also the data unit to be replicated by <a href="https://raft.github.io/">Raft</a>, to archive <a href="understanding-tikv/scalability/../high-availability/intro.html"><strong>High-Availability</strong></a>. A region is likewise a <code>Raft Group</code> in Raft algorithm, composed of one or more <code>Peer</code>s, while a peer is one of the replica of a partition.</p>
<p><img src="understanding-tikv/scalability/../../media/scalability-region.png" alt="scalability-region" />
<em>Diagram 2, Region &amp; Replication [1]</em></p>
<p>How does TiKV split data into regions? As data element of TiKV is key-value pair, we first decide which keys should be put into a region. In general, there are two approaches:</p>
<ul>
<li>
<p>Sharding by hash: splitting by hash of keys (e.g. <a href="https://en.wikipedia.org/wiki/Consistent_hashing">consistent hashing</a>). It is easier to be implemented, as location of keys can be calculated by clients. But it is more difficult to scale up, consistent hashing makes things more complicated, and not efficient to range queries.</p>
</li>
<li>
<p>Sharding by range: splitting by range of keys. It is simple, good for scan, easy to scale by splitting and merging, even can switch to sharding by hash easily. But it needs additional management of metadata of partition.</p>
</li>
</ul>
<p>TiKV splits data by key range. Each region contains a continuous range of keys. The <a href="https://github.com/tikv/pd"><strong>Placement Driver (PD) server</strong></a> stores the <code>[start_key, end_key)</code> and other <a href="https://github.com/pingcap/kvproto/blob/release-5.2/proto/metapb.proto#L64-L76">metadata</a> of each region, and performs the <a href="understanding-tikv/scalability/scheduling.html">scheduling</a> of regions.</p>
<p>Then, we determine how many key-value pairs should be stored in one region. The size of a region should not be too small, otherwise the management cost of too many regions would be high. Meanwhile, the size should not be too large, or else region migration would be expensive and time-consuming.</p>
<p>By default, each region is expected to be about 96MB (see <a href="https://docs.pingcap.com/tidb/stable/tikv-configuration-file#region-split-size">region-split-size</a>) in size. Large regions more than 144MB (see <a href="https://docs.pingcap.com/tidb/stable/tikv-configuration-file#region-max-size">region-max-size</a>) will be split into two or more regions with 96MB each. Small adjacent regions less than 20MB (see <a href="https://docs.pingcap.com/tidb/stable/pd-configuration-file#max-merge-region-size">max-merge-region-size</a>) will be merged to one.</p>
<p>Moreover, each region is expected to contain more or less 960000 (see <a href="https://docs.pingcap.com/tidb/stable/tikv-configuration-file#region-split-keys">region-split-keys</a>) keys, because region size calculation will need to scan all keys in the region. Big regions with more than 1440000 (see <a href="https://docs.pingcap.com/tidb/stable/tikv-configuration-file#region-max-keys">region-max-keys</a>) keys will be split, while regions with more than 200000 (see <a href="https://docs.pingcap.com/tidb/stable/pd-configuration-file#max-merge-region-keys">max-merge-region-keys</a>) keys will <strong>NOT</strong> be merged.</p>
<h2 id="reference"><a class="header" href="#reference">Reference</a></h2>
<p>[1] Wenxuan, PingCAP, <a href="https://docs.google.com/presentation/d/1zF7yRiGt643orPHRFjorUfE8ZTTGwEw9Rdxv6mEc3eQ/edit?usp=sharing">&quot;DEEP DIVE TIKV&quot;</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="scheduling"><a class="header" href="#scheduling">Scheduling</a></h1>
<p>This section introduces the scheduling mechanism.</p>
<p>The scheduling mechanism is mainly by summarizing the collected cluster real-time status information (including the heartbeat of the region and the heartbeat of the store), and then judging whether scheduling needs to be generated according to different strategies, and then generate scheduling <code>Operator</code> which is send to TiKV to do scheduling. the <code>Operator</code>struct like:</p>
<pre><code class="language-go">    // Operator contains execution steps generated by scheduler.
    type Operator struct {
        desc             string
        brief            string
        regionID         uint64
        regionEpoch      *metapb.RegionEpoch
        kind             OpKind
        steps            []OpStep
        stepsTime        []int64 // step finish time
        currentStep      int32
        status           OpStatusTracker
        level            core.PriorityLevel
    }
</code></pre>
<p>Each scheduling <code>Operator</code> is only used to operate a region migration, which including some <code>OpSteps</code>: add peer, transfer the raft group leader and remove peer. an <code>Operator</code> will record the ID of the operator region, the relative strategy name, operator priority level etc. The <code>Operator</code> in PD may be generated from two operate, one is the <code>checker</code> and the other is the <code>scheduler</code>. The generated schedule will be stored in a map, and then it will be returned to the corresponding TiKV through the response when the region heartbeat comes. Let us first look at how checker and scheduler work.</p>
<h2 id="checker"><a class="header" href="#checker">Checker</a></h2>
<p>After PD server started, there is a <a href="https://github.com/tikv/pd/blob/release-5.2/server/cluster/coordinator.go#L90-L158">background worker</a> will polling all regions and then check the health status of each region:</p>
<pre><code class="language-go">    func (c *coordinator) patrolRegions() {
        timer := time.NewTimer(c.cluster.GetPatrolRegionInterval())
        for {
            select {
            case &lt;-timer.C:
                timer.Reset(c.cluster.GetPatrolRegionInterval())
            case &lt;-c.ctx.Done():
                log.Info(&quot;patrol regions has been stopped&quot;)
                return
            }

            regions := c.cluster.ScanRegions(key, nil, patrolScanRegionLimit)
            for _, region := range regions {
                if c.checkRegion(region) {
                    break
                }
            }
        }
    }
</code></pre>
<p>In this function, <code>checkRegion</code> will be executed to determine whether the region needs to be scheduled. If a schedule <code>Operator</code> is generated, it will be sent to TiKV through the heartbeat of this region. The initialization of the checker can be found in <code>coordinator.go</code>, which mainly contains <a href="https://github.com/tikv/pd/blob/release-5.2/server/schedule/checker_controller.go#L64-L107">four checkers</a>: <code>RuleChecker</code>, <code>MergeChecker</code>, <code>JointStateChecker</code> and <code>SplitChecker</code>.</p>
<p><code>RuleChecker</code> is the most critical checker. It will check whether a region has down peers or offline peers. It will also check whether the number of replicas of the current region is the same as the number of replicas specified in the <a href="https://docs.pingcap.com/tidb/stable/configure-placement-rules#placement-rules"><code>Placement Rules</code></a>. If the conditions are met, it will trigger the logic of the corresponding supplementary replicas or delete the redundant replicas. In addition, <code>RuleChecker</code> will also check whether the current copy of this region is placed in the most reasonable place, and if not, it will be placed in a more reasonable place.</p>
<p><code>MergeChecker</code> will check whether the current region meets the merge conditions, such as whether the size of the region is less than <code>max-merge-region-size</code>, whether the key of the region is less than <code>max-merge-region-keys</code>, and whether there has been no split operation in the recent period, etc. If these conditions are met, an adjacent region will be selected to try to merge the two regions.</p>
<h2 id="scheduler"><a class="header" href="#scheduler">Scheduler</a></h2>
<p>Let's first take a look at the code about the scheduler running process. Schedulers are running concurrently. Each scheduler has a <a href="https://github.com/tikv/pd/blob/release-5.2/server/cluster/coordinator.go#L762-L789">scheduler controller</a>, which running in a background worker:</p>
<pre><code class="language-go">func (c *coordinator) runScheduler(s *scheduleController) {
    defer logutil.LogPanic()
    defer c.wg.Done()
    defer s.Cleanup(c.cluster)

    timer := time.NewTimer(s.GetInterval())
    defer timer.Stop()

    for {
        select {
        case &lt;-timer.C:
            timer.Reset(s.GetInterval())
            if !s.AllowSchedule() {
                continue
            }
            if op := s.Schedule(); len(op) &gt; 0 {
                added := c.opController.AddWaitingOperator(op...)
                log.Debug(&quot;add operator&quot;, zap.Int(&quot;added&quot;, added), zap.Int(&quot;total&quot;, len(op)), zap.String(&quot;scheduler&quot;, s.GetName()))
            }

        case &lt;-s.Ctx().Done():
            log.Info(&quot;scheduler has been stopped&quot;,
                zap.String(&quot;scheduler-name&quot;, s.GetName()),
                errs.ZapError(s.Ctx().Err()))
            return
        }
    }
}
</code></pre>
<p>Similar to the checker, when the PD starts, the specified scheduler will be added according to the configuration. Each scheduler runs in a goroutine by executing <code>go runScheduler</code>, and then executes the <code>Schedule()</code> function at a dynamically adjusted time interval.</p>
<p>There are two things that a function has to do. The first is to execute the scheduling logic of the corresponding scheduler to determine whether to generate an <code>Operator</code>, and the other is to determine the time interval for the next execution of <code>Schedule()</code>.</p>
<p>PD contains many schedulers. For details, you can check the <code>server/schedulers</code> package, which contains the implementation of all schedulers. The schedulers that PD will run by default include <code>balance-region-scheduler</code>, <code>balance-leader-scheduler</code>, and <code>balance-hot-region-scheduler</code>. Let's take a look at the specific functions of these schedulers:</p>
<ul>
<li>The <a href="https://github.com/tikv/pd/blob/release-5.2/server/schedulers/balance_region.go#L136-L144"><code>balance-region-scheduler</code></a> calculates a score based on the size of the region size on a store and the usage of available space. Then, according to the calculated score, the region is evenly distributed to each store through the <code>Operator</code> that generates the balance-region. The reason why the available space is considered here is that the actual situation may have differences in storage capacity of different stores.</li>
<li>The <a href="https://github.com/tikv/pd/blob/release-5.2/server/schedulers/balance_leader.go#L137-L153"><code>balance-leader-scheduler</code></a> is similar to the balance-region-scheduler. It calculates a score based on the region count, and then uses the <code>Operator</code> that generates the balance-leader to distribute the leaders as evenly as possible across the stores.</li>
<li>The <a href="https://github.com/tikv/pd/blob/release-5.2/server/schedulers/hot_region.go#L152-L155"><code>balance-hot-region-scheduler</code></a> implements the related logic of hot spot scheduling. For TiDB, if there are hot spots and only a few stores have hot spots, then the overall resource utilization of the system will be lowered, and it is easy to form a system bottleneck. Therefore, PD also needs to count the hot spots in response to this situation. Come out, and by generating the corresponding schedule, the hot spots are scattered to all stores as much as possible. So that all stores can share the pressure of reading and writing.</li>
</ul>
<p>There are some other schedulers to choose from. Each scheduler of PD implements an interface called <a href="https://github.com/tikv/pd/blob/release-5.2/server/schedule/scheduler.go#L33-L45">Scheduler</a>:</p>
<pre><code class="language-go">// Scheduler is an interface to schedule resources.
type Scheduler interface {
    http.Handler
    GetName() string
    // GetType should in accordance with the name passing to schedule.RegisterScheduler()
    GetType() string
    EncodeConfig() ([]byte, error)
    GetMinInterval() time.Duration
    GetNextInterval(interval time.Duration) time.Duration
    Prepare(cluster opt.Cluster) error
    Cleanup(cluster opt.Cluster)
    Schedule(cluster opt.Cluster) []*operator.Operator
    IsScheduleAllowed(cluster opt.Cluster) bool
}
</code></pre>
<p>The most important thing is the <code>Schedule()</code> interface function, which is used to implement the specific scheduling-related logic of each scheduler.</p>
<p>In addition, the interface function <code>IsScheduleAllowed()</code> is used to determine whether the scheduler is allowed to execute the corresponding scheduling logic. Before executing the scheduling logic, each scheduler will firstly call this function to determine whether the scheduling rate is exceeded. Specifically, in the code, this function is called <code>AllowSchedule()</code>, and then the <code>IsScheduleAllowed()</code> method implemented by different schedulers is called.</p>
<p>PD can control the speed at which the scheduler generates operators by setting the limit, but the limit here is just one that maintains a window size, and different operator types have their own window sizes. For example, <code>balance-region</code> schedulers and <code>balance-hot-region</code> schedulers will generate operators related to migrate region, and the type of this operator is <code>OpRegion</code>. We can control the operator of this type of <code>OpRegion</code> by adjusting the <code>region-schedule-limit</code> parameter. The specific operator type definition can be found in the file <a href="https://github.com/tikv/pd/blob/release-5.2/server/schedule/operator/operator.go"><code>operator.go</code></a>. An operator may contain multiple types. For example, the operator generated by <code>balance-hot-region</code> may belong to both <code>OpRegion</code> and <code>OpHotRegion</code>.</p>
<h2 id="more"><a class="header" href="#more">More</a></h2>
<p>This section mainly introduces the main operation process of PD scheduling. For more details, you can continue to refer to the corresponding code study. And, welcome to contribute <a href="https://github.com/tikv/pd/contribute">good first issues</a>.</p>
<p>See more information about PD implementation on <a href="https://github.com/tikv/pd/wiki">its Wiki page</a>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="high-availability"><a class="header" href="#high-availability">High Availability</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="raft"><a class="header" href="#raft">Raft</a></h1>
<blockquote>
<p>what is Raft, how it works</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="raft-rs"><a class="header" href="#raft-rs">raft-rs</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="leader-lease"><a class="header" href="#leader-lease">Leader Lease</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="hibernate-region"><a class="header" href="#hibernate-region">Hibernate Region</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="multi-raft"><a class="header" href="#multi-raft">Multi-Raft</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="split"><a class="header" href="#split">Split</a></h1>
<blockquote>
<p>region epoch, conf version</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="merge"><a class="header" href="#merge">Merge</a></h1>
<blockquote>
<p>PrepareMerge, CommitMerge, RollbakMerge</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="raftstore"><a class="header" href="#raftstore">RaftStore</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="actor-model"><a class="header" href="#actor-model">Actor Model</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="fsm"><a class="header" href="#fsm">FSM</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="transaction"><a class="header" href="#transaction">Transaction</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="percolator"><a class="header" href="#percolator">Percolator</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="tso"><a class="header" href="#tso">TSO</a></h1>
<blockquote>
<p>how pd tso works, how global/local tso works</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="encode"><a class="header" href="#encode">Encode</a></h1>
<blockquote>
<p>mvcc encode, memcomparable encode, key adjustment on region split</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="command"><a class="header" href="#command">Command</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="latch-and-scheduler"><a class="header" href="#latch-and-scheduler">Latch and Scheduler</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="pessimistic-transaction"><a class="header" href="#pessimistic-transaction">Pessimistic Transaction</a></h1>
<blockquote>
<p>pessimistic lock, deadlock detecter</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="async-commit"><a class="header" href="#async-commit">Async Commit</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="1pc"><a class="header" href="#1pc">1PC</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="stale-read"><a class="header" href="#stale-read">Stale Read</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="cdc"><a class="header" href="#cdc">CDC</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rocksdb"><a class="header" href="#rocksdb">RocksDB</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="encode-1"><a class="header" href="#encode-1">Encode</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="import-and-export"><a class="header" href="#import-and-export">Import and Export</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="io-rate-limiter"><a class="header" href="#io-rate-limiter">IO Rate Limiter</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="tikv-coprocessor"><a class="header" href="#tikv-coprocessor">TiKV Coprocessor</a></h1>
<h2 id="why-coprocessor"><a class="header" href="#why-coprocessor">Why Coprocessor?</a></h2>
<p>TiKV is a distributed key-value storage engine made for TiDB. When TiDB executes a query, basically, it will need to retrieve and scan full rows from TiKV. Consider the following query: </p>
<p><img src="understanding-tikv/coprocessor/../../media/tikv-distributed-execution.png" alt="TiKV Distributed Execution" /></p>
<p>Without TiKV coprocessor, TiDB needs to retrieve all rows from TiKV, and then scan and filter them on the TiDB side, even if we only have a single number as the query result. In order to reduce the network traffic for a query, TiDB pushes some computations down to TiKV Coprocessor, which runs queries on the TiKV side.</p>
<p>A TiKV cluster is composed of multiple TiKV nodes, and thus TiKV coprocessor cannot run all queries which TiDB supports. On one side, TiKV itself only holds part of the data which a query needs. Therefore, for an aggregation query, each TiKV node can only calculate partial sums, and TiDB needs to aggregate the partial sums into the final sum. On the other side, TiKV Coprocessor only supports a limited number of executors. Complex operations like join cannot be done on TiKV.</p>
<p>In this article, we will introduce the basics of TiKV Coprocessor from a developer's perspective.</p>
<h2 id="overview-of-tikv-coprocessor"><a class="header" href="#overview-of-tikv-coprocessor">Overview of TiKV Coprocessor</a></h2>
<p>The TiKV Coprocessor is able to handle multiple kinds of requests. Previously, we mentioned &quot;push-down execution&quot;. This is handled by DAG handler in the TiKV Coprocessor. The Coprocessor also supports Checksum and Analyze requests. At the same time, the TiKV Coprocessor is not limited to TiDB queries. In Coprocessor v2, developers can dynamically load Coprocessor plugins into a TiKV node, which could process any execution requests that need access to key-value data stored on the TiKV side.</p>
<p>The code for the TiKV Coprocessor is stored in <a href="https://github.com/tikv/tikv/tree/master/src/coprocessor">src/coprocessor</a> directory. And folders begin with <code>tidb_query_</code> in <a href="https://github.com/tikv/tikv/tree/master/components">components</a> is used by TiKV Coprocessor to run TiDB queries.</p>
<p>Here we focus on DAG handler in the TiKV Coprocessor. Running queries on the TiKV side requires two things: a plan to run query, and the data needed by a query.</p>
<p><img src="understanding-tikv/coprocessor/../../media/copr-overview.png" alt="TiKV Coprocessor Executors" /></p>
<p>For a single query, TiDB will send the plan down to TiKV (the control flow), and TiKV will scan rows of table from the local storage engine (the data flow). TiKV Coprocessor executes the plan with data from the local storage engine, and sends the result back to TiDB.</p>
<p>The plan and the data exist in different forms throughout the query execution process. In the following parts, we will focus on how they exist on TiKV in each stage.</p>
<h2 id="the-plan"><a class="header" href="#the-plan">The Plan</a></h2>
<p>When TiDB needs to run a query on TiKV Coprocessor, it will encode the plan in the form of protobuf messages. The schema of the query plan itself is defined in <a href="https://github.com/pingcap/tipb">tipb</a> repository. Inside tipb, we have all SQL expressions supported by TiKV (and TiDB), each with a unique ID, and we define components used by a query, like executors and aggregators.</p>
<p>The plan is then sent to the gRPC service on the TiKV side, which requires another protobuf schema definition. The definition for that is in the <a href="https://github.com/pingcap/kvproto/blob/master/proto/coprocessor.proto">kvproto</a> repository. The plan is encoded in the <code>data</code> field of the request. Each Coprocessor request will specify the key range (or region) to operate on.</p>
<pre><code class="language-protobuf">message Request {
    kvrpcpb.Context context = 1;
    int64 tp = 2;
    bytes data = 3;
    uint64 start_ts = 7;
    repeated KeyRange ranges = 4;
    // ...
}
</code></pre>
<p>As a developer, you may want to see what plan is pushed down to TiKV when running a query. This could be easily done with an SQL <code>explain</code> statement.</p>
<pre><code class="language-plain">MySQL [test]&gt; explain select count(*) from test where x &gt; 10;
+-----------------------------+---------+-----------+---------------+-------------------------------------------------+
| id                          | estRows | task      | access object | operator info                                   |
+-----------------------------+---------+-----------+---------------+-------------------------------------------------+
| StreamAgg_17                | 1.00    | root      |               | funcs:count(Column#4)-&gt;Column#2                 |
| └─TableReader_18            | 1.00    | root      |               | data:StreamAgg_9                                |
|   └─StreamAgg_9             | 1.00    | cop[tikv] |               | funcs:count(1)-&gt;Column#4                        |
|     └─TableRangeScan_16     | 3333.33 | cop[tikv] | table:test    | range:(10,+inf], keep order:false, stats:pseudo |
+-----------------------------+---------+-----------+---------------+-------------------------------------------------+
4 rows in set (0.002 sec)
</code></pre>
<p>A push-down plan is marked as <code>cop[tikv]</code> in the <code>task</code> column.</p>
<h2 id="the-data"><a class="header" href="#the-data">The Data</a></h2>
<h3 id="on-disk-format"><a class="header" href="#on-disk-format">On-Disk Format</a></h3>
<p>TiKV stores its data by rows in its local KV storage engine (as of now, RocksDB or TitanDB). Upon the local KV storage engine, there is a MVCC transactional layer, called TxnKV, which Coprocessor reads data from. The key in TxnKV is composed of the table information and the primary key of a row. And other columns of this row is stored as the value in storage engine. For example,</p>
<pre><code class="language-plain">t10_r1 --&gt; [&quot;TiDB&quot;, &quot;SQL Layer&quot;, 10]
t10_r2 --&gt; [&quot;TiKV&quot;, &quot;KV Engine&quot;, 20]
t10_r3 --&gt; [&quot;PD&quot;, &quot;Manager&quot;, 30]
</code></pre>
<p>The TiDB row format (v2) is described in the <a href="https://github.com/pingcap/tidb/blob/master/docs/design/2018-07-19-row-format.md">A new storage row format for efficient decoding</a> RFC.</p>
<h3 id="in-memory-format"><a class="header" href="#in-memory-format">In-memory Format</a></h3>
<p>The executors (will be introduced later) will scan the data from  TxnKV in small batches, and store them in memory. Contrary to the on-disk format, data are stored in a columnar way in memory. The memory format is called &quot;Chunk format&quot; in TiDB, and is in some way very similar to the Apache Arrow format. The implementation details are described in the <a href="https://github.com/tikv/rfcs/blob/master/text/0043-copr-chunk.md">Using chunk format in coprocessor framework</a> RFC, and <a href="https://docs.google.com/presentation/d/1fUQTJ6gEscHUag9OhIIePL9uiIYJ61TSpfor-pajBoE/edit#slide=id.g446c4deb4d_0_341">this slide</a>. The format is implemented in <a href="https://github.com/tikv/tikv/tree/master/components/tidb_query_datatype/src/codec/data_type">components/tidb_query_datatype</a> beginning with <code>chunked_vec_</code>.</p>
<h2 id="inside-coprocessor"><a class="header" href="#inside-coprocessor">Inside Coprocessor</a></h2>
<p><img src="understanding-tikv/coprocessor/../../media/inside-copr.png" alt="TiKV Coprocessor Internals" /></p>
<p>The TiKV Coprocessor contains necessary components to handle a cop read request, which include the expression framework, the aggregators, and the executors. We will cover these parts in the following chapters.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="tidb-expression-executor"><a class="header" href="#tidb-expression-executor">TiDB Expression Executor</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="coprocessor-plugin"><a class="header" href="#coprocessor-plugin">Coprocessor Plugin</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
